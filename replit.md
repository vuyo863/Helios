# Pionex Bot Profit Tracker

## Overview
Full-stack web application designed to track and analyze profits generated by Pionex trading bots. The project aims to provide users with comprehensive insights into their bot performance through a React-based frontend and an Express.js backend. Its core capabilities include visualizing profit trends, comparing different bot types, and offering advanced analytical features.

## User Preferences
- **Sprache**: Deutsch (einfache Alltagssprache)
- **Kommunikation**: Direkt, ohne Umschweife

## System Architecture

### UI/UX
The frontend is built with React and TypeScript, leveraging `shadcn/ui` and Tailwind CSS for a modern and responsive user interface. Charting functionalities are powered by Recharts, enabling dynamic and interactive data visualization. Routing is managed using Wouter.

The dashboard features three primary chart modes:
1.  **MainChart**: Displays detailed performance for a single selected bot type, showing total profit, average daily profit, real daily profit, total capital, and total profit percentage. It includes clickable metric cards, a robust marker system (U1, C1, etc.), eye and pencil modes for interaction, and zoom/pan capabilities.
2.  **Compare Mode**: Allows comparison of two or more bot types, visualizing their performance with color-coded lines. This mode highlights start and end points for updates, displaying runtime information.
3.  **Edit (Added) Mode**: Aggregates data from multiple bot types, primarily focusing on end values rather than a continuous graph. This mode includes sub-toggles for "Analysis" and "Overlay."
    *   **Analysis**: Provides correct metric display for individual analysis, particularly useful within the pencil mode for specific update periods.
    *   **Overlay**: A planned feature for alternative data representation.

### Technical Implementations
*   **State Management**: Extensive use of TypeScript-typed state variables to manage chart modes, selected bot types, and interaction modes (`isMultiBotChartMode`, `isMultiSelectCompareMode`, `isSingleBotMode`, `markerViewActive`, `markerEditActive`, `compareActive`).
*   **Data Handling**: Dedicated `useMemo` hooks for optimizing chart data preparation for `chartData` (single bot), `multiBotChartData` (added mode), and `compareChartData` (compare mode).
*   **Color System**: A consistent color palette is used for various metrics (e.g., green for 'Gesamtprofit', blue for 'Ø Profit/Tag') and specific chart elements (e.g., neon blue for active elements, red for end points, green for start points).
*   **Bot Type Management**: Comprehensive CRUD operations for bot types, including CSV/Excel upload and update history tracking.

### Feature Specifications
*   **Marker System**: Allows users to define and interact with specific points (markers) on the charts for event tracking and analysis.
*   **Zoom & Pan**: Interactive zooming and panning on chart axes, particularly in analysis modes.
*   **AI-Analysis**: Integration with OpenAI for automatic insights and chart data summarization, provided on a dedicated page (`ai-analysis.tsx`).

### System Design Choices
*   **Golden State Doctrine**: Critical, stable, and fully tested parts of the codebase are designated as "Golden State" and are strictly forbidden from modification to maintain stability and prevent regressions. This includes the MainChart, Compare Mode, Bot-Type CRUD functionalities, and the entire AI-Analysis page.
*   **Modular Architecture**: Separation of concerns between frontend and backend, and within the frontend, distinct modules for different chart modes and functionalities.

## External Dependencies
*   **Database**: Neon Serverless PostgreSQL, managed with Drizzle ORM for database interactions.
*   **Backend Framework**: Express.js with TypeScript for API endpoints and server-side logic.
*   **Frontend Libraries**:
    *   React: Core UI library.
    *   Recharts: For data visualization and charting.
    *   shadcn/ui & Tailwind CSS: For UI components and styling.
    *   Wouter: For client-side routing.
*   **Validation**: Zod for schema validation.
*   **AI Integration**: OpenAI API for AI-powered analysis features.
*   **Storage**: In-memory `MemStorage` for server-side data handling.

---

## Dezember 2025 - Zeitgewichtetes Investment (Bot-Type-Page)

**Änderung:**
- Gesamtinvestment-Ø auf Bot-Type-Cards: **zeitgewichtete Berechnung**
- Investitionsmenge-Ø (Basis-Investment): zeitgewichtet berechnet (NICHT in UI, für API)

**Formel:** `Σ(investment × runtime) / Σ(runtime)`

**Runtime:** durchschnittliche Laufzeit (avgRuntime) - NICHT from-until!

**Datei:** `client/src/pages/bot-types.tsx` (Zeilen 522-625)

---

## Dezember 2025 - Dashboard Content Cards Golden State

### GOLDEN STATE - Nicht mehr anfassen!

**Gesamt-Modus:**
- ✅ Gesamtkapital (zeitgewichtet mit avgRuntime über ALLE Updates aller aktiven Bot-Types)
- ✅ Investitionsmenge (zeitgewichtet mit avgRuntime über ALLE Updates aller aktiven Bot-Types)
- ✅ Gesamtprofit % (berechnet: totalProfit / displayedInvestment * 100)
- ✅ Gesamtprofit (Summe aller Profits)

**Added-Modus:**
- ✅ Gesamtkapital (zeitgewichtet mit avgRuntime über ALLE Updates ausgewählter Bot-Types)
- ✅ Investitionsmenge (zeitgewichtet mit avgRuntime über ALLE Updates ausgewählter Bot-Types)
- ✅ Gesamtprofit % (berechnet: totalProfit / displayedInvestment * 100)
- ✅ Gesamtprofit (Summe aller Profits)

**Compare-Modus:**
- ✅ Alle Content Cards (Golden State)

**Formel für Investment:**
`Σ(Investment × avgRuntime) / Σ(avgRuntime)` über ALLE Updates zusammen (wie ein großer Bot-Type)

**Zeitfilter im Added-Modus:**
- Prüft ob Update im Zeitfenster liegt (from-until Überlappung)
- Verwendet IMMER avgRuntime für Gewichtung (nicht from-until!)

---

## Dezember 2025 - Ø Profit/Tag Golden State

### GOLDEN STATE - Nicht mehr anfassen!

**Gesamt-Modus:**
- ✅ Ø Profit/Tag: Pro Bot-Type `totalProfit / totalHours * 24`, dann ADDIEREN

**Added-Modus:**
- ✅ Ø Profit/Tag mit intelligenter Logik:
  - **ALLE Updates enthalten:** `totalProfit / totalHours * 24` pro Bot-Type, dann ADDIEREN
  - **Nur TEIL der Updates (Zeitfilter):** Durchschnitt von `avgGridProfitDay` pro Bot-Type, dann ADDIEREN

**Formel für Gesamt/Alle Updates:**
Pro Bot-Type: `Σ(overallGridProfitUsdt) / Σ(parseRuntimeToHours(avgRuntime)) * 24`
Dann werden alle Bot-Type-Ergebnisse addiert.

**Formel für Zeitfilter (Teil der Updates):**
Pro Bot-Type: `Σ(avgGridProfitDay) / Anzahl_Updates`
Dann werden alle Bot-Type-Ergebnisse addiert.

**Datei:** `client/src/pages/dashboard.tsx` (Zeilen 2002-2059)

---

## TODO: Noch zu bearbeiten

**Added-Modus Content Cards:**
- ⏳ Real Profit/Tag - noch offen (5. und letzte Content Card)