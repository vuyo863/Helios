ğŸ¯ Ziel

Du willst, dass die Achse:

immer den gewÃ¤hlten Zeitraum vollstÃ¤ndig abdeckt,

aber nicht zu viele Labels anzeigt,

und bei unterschiedlichen Zoom-Levels intuitiv lesbar bleibt,

egal ob du z. B. 1 Tag, 3 Wochen oder 1 Jahr betrachtest.

ğŸ“ Grundprinzip

ğŸ’¡ Die Anzahl der X-Axis-Labels soll abhÃ¤ngig sein von:

der LÃ¤nge des Zeitraums, und

der gewÃ¤hlten Einheit (Stunden, Tage, Wochen, Monate)

Die Achse entscheidet also dynamisch, wann ein Label gezeigt wird, statt feste Regeln zu benutzen.

ğŸ§  Rechnung / Formel
Schritt 1 â€” Zeitraum berechnen

Du berechnest zuerst:

totalHours = (endTime - startTime) / (1000 * 60 * 60)
totalDays  = totalHours / 24
totalWeeks = totalDays / 7
totalMonths â‰ˆ totalDays / 30
totalYears  â‰ˆ totalDays / 365

ğŸ“Š Adaptive Interval Formel
â¤ 1. Stunden-Ansicht

Wenn viewMode === "hours":

if totalHours <= 48:
  tickIntervalHours = 1
elif totalHours <= 168:        // bis 1 Woche
  tickIntervalHours = 2
elif totalHours <= 336:        // bis 2 Wochen
  tickIntervalHours = 4
elif totalHours <= 720:        // bis 1 Monat
  tickIntervalHours = 6
else
  tickIntervalHours = Math.ceil(totalHours / 100)  // grob


ğŸ”¹ Label-Regel:

Immer bei 00:00 eines Tages â†’ Datum (z. B. â€26.11â€œ),

sonst jede tickIntervalHours â†’ Uhrzeit.

â¤ 2. Tages-Ansicht

Wenn viewMode === "days":

if totalDays <= 7:
  tickIntervalDays = 1
elif totalDays <= 30:
  tickIntervalDays = 2
elif totalDays <= 90:
  tickIntervalDays = 7
else
  tickIntervalDays = Math.ceil(totalDays / 25)


ğŸ”¹ Label-Regel:

Jeder tickIntervalDays-Tag â†’ Datum anzeigen

â¤ 3. Wochen-Ansicht

Wenn viewMode === "weeks":

if totalWeeks <= 4:
  tickIntervalWeeks = 1
elif totalWeeks <= 12:
  tickIntervalWeeks = 2
else
  tickIntervalWeeks = Math.ceil(totalWeeks / 10)


ğŸ”¹ Label-Regel:

Jede tickIntervalWeeks â†’ â€KW xxâ€œ oder â€Monat-Jahrâ€œ

â¤ 4. Monate & Jahre (falls du willst)

Analog:

if totalMonths <= 6:
  tickIntervalMonths = 1
else
  tickIntervalMonths = Math.ceil(totalMonths / 6)


und

if totalYears <= 3:
  tickIntervalYears = 1
else
  tickIntervalYears = Math.ceil(totalYears / 3)


Dann Labels:

Monatssicht â†’ â€Nov 2025â€œ

Jahressicht â†’ â€2025â€œ

ğŸ›  Tick-Formatter-Logik

So sieht die praktische Umsetzung in einer formatTick-Funktion aus:

function formatTick(timestamp, index, ticks, viewMode) {
  const d = new Date(timestamp);

  if (viewMode === "hours") {
    const hour = d.getHours();
    if (hour === 0 || index % tickIntervalHours === 0) {
      return hour === 0
        ? d.toLocaleDateString("de-DE", { day: "2-digit", month: "2-digit" })
        : d.toLocaleTimeString("de-DE", { hour: "2-digit", minute: "2-digit" });
    }
    return "";
  }

  if (viewMode === "days") {
    if (index % tickIntervalDays === 0) {
      return d.toLocaleDateString("de-DE", { day: "2-digit", month: "2-digit" });
    }
    return "";
  }

  if (viewMode === "weeks") {
    if (index % tickIntervalWeeks === 0 || d.getDay() === 1) {
      return "KW " + getISOWeek(d);
    }
    return "";
  }
}

ğŸ” Beispiel Visualisierung
ğŸŸ¡ Zeitraum 2 Tage + Stunden-Ansicht

Ticks: jede Stunde
Labels: jede 1â€“2 Stunden + Tageswechsel

| 01:00 | 03:00 | 05:00 | 07:00 | 09:00 | 26.11 | â€¦

ğŸŸ¢ Zeitraum 3 Wochen + Stunden-Ansicht

Ticks: jede Stunde
Labels: jede 3â€“4 Stunden + Tageswechsel

| 00:00 | 04:00 | 08:00 | 12:00 | KW 48 | â€¦

ğŸ”µ Zeitraum 1 Monat + Tages-Ansicht

Ticks: jeder Tag
Labels: jeder zweite Tag

| 15.11 | 17.11 | 19.11 | 21.11 | 23.11 | 25.11 |

ğŸ§  Fazit fÃ¼r Sie, Sir

âœ… Die Achse bleibt immer vollstÃ¤ndig fÃ¼r den Zeitraum
âœ… Die Labels passen sich intelligent der LÃ¤nge an
âœ… Bei Stunden sieht man ab und zu Date-Markierungen
âœ… Bei Wochen & Monaten wird die Achse nicht zu Ã¼berladen